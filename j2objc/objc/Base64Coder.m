//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/fep/dev/android/office/mnc/digital/analytics/mobile-sdk/ios/j2objc/java/Base64Coder.java
//

#include "Base64Coder.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Math.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"

#if !__has_feature(objc_arc)
#error "Base64Coder must be compiled with ARC (-fobjc-arc)"
#endif

@interface Base64Coder ()

- (instancetype)init;

@end

inline NSString *Base64Coder_get_systemLineSeparator(void);
static NSString *Base64Coder_systemLineSeparator;
J2OBJC_STATIC_FIELD_OBJ_FINAL(Base64Coder, systemLineSeparator, NSString *)

inline IOSCharArray *Base64Coder_get_map1(void);
static IOSCharArray *Base64Coder_map1;
J2OBJC_STATIC_FIELD_OBJ_FINAL(Base64Coder, map1, IOSCharArray *)

inline IOSByteArray *Base64Coder_get_map2(void);
static IOSByteArray *Base64Coder_map2;
J2OBJC_STATIC_FIELD_OBJ_FINAL(Base64Coder, map2, IOSByteArray *)

__attribute__((unused)) static void Base64Coder_init(Base64Coder *self);

__attribute__((unused)) static Base64Coder *new_Base64Coder_init(void) NS_RETURNS_RETAINED;

__attribute__((unused)) static Base64Coder *create_Base64Coder_init(void);

J2OBJC_INITIALIZED_DEFN(Base64Coder)

@implementation Base64Coder

+ (NSString *)encodeStringWithNSString:(NSString *)s {
  return Base64Coder_encodeStringWithNSString_(s);
}

+ (NSString *)encodeLinesWithByteArray:(IOSByteArray *)inArg {
  return Base64Coder_encodeLinesWithByteArray_(inArg);
}

+ (NSString *)encodeLinesWithByteArray:(IOSByteArray *)inArg
                               withInt:(jint)iOff
                               withInt:(jint)iLen
                               withInt:(jint)lineLen
                          withNSString:(NSString *)lineSeparator {
  return Base64Coder_encodeLinesWithByteArray_withInt_withInt_withInt_withNSString_(inArg, iOff, iLen, lineLen, lineSeparator);
}

+ (IOSCharArray *)encodeWithByteArray:(IOSByteArray *)inArg {
  return Base64Coder_encodeWithByteArray_(inArg);
}

+ (IOSCharArray *)encodeWithByteArray:(IOSByteArray *)inArg
                              withInt:(jint)iLen {
  return Base64Coder_encodeWithByteArray_withInt_(inArg, iLen);
}

+ (IOSCharArray *)encodeWithByteArray:(IOSByteArray *)inArg
                              withInt:(jint)iOff
                              withInt:(jint)iLen {
  return Base64Coder_encodeWithByteArray_withInt_withInt_(inArg, iOff, iLen);
}

+ (NSString *)decodeStringWithNSString:(NSString *)s {
  return Base64Coder_decodeStringWithNSString_(s);
}

+ (IOSByteArray *)decodeLinesWithNSString:(NSString *)s {
  return Base64Coder_decodeLinesWithNSString_(s);
}

+ (IOSByteArray *)decodeWithNSString:(NSString *)s {
  return Base64Coder_decodeWithNSString_(s);
}

+ (IOSByteArray *)decodeWithCharArray:(IOSCharArray *)inArg {
  return Base64Coder_decodeWithCharArray_(inArg);
}

+ (IOSByteArray *)decodeWithCharArray:(IOSCharArray *)inArg
                              withInt:(jint)iOff
                              withInt:(jint)iLen {
  return Base64Coder_decodeWithCharArray_withInt_withInt_(inArg, iOff, iLen);
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  Base64Coder_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LNSString;", 0x9, 0, 1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x9, 2, 3, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x9, 2, 4, -1, -1, -1, -1 },
    { NULL, "[C", 0x9, 5, 3, -1, -1, -1, -1 },
    { NULL, "[C", 0x9, 5, 6, -1, -1, -1, -1 },
    { NULL, "[C", 0x9, 5, 7, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x9, 8, 1, -1, -1, -1, -1 },
    { NULL, "[B", 0x9, 9, 1, -1, -1, -1, -1 },
    { NULL, "[B", 0x9, 10, 1, -1, -1, -1, -1 },
    { NULL, "[B", 0x9, 10, 11, -1, -1, -1, -1 },
    { NULL, "[B", 0x9, 10, 12, -1, -1, -1, -1 },
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(encodeStringWithNSString:);
  methods[1].selector = @selector(encodeLinesWithByteArray:);
  methods[2].selector = @selector(encodeLinesWithByteArray:withInt:withInt:withInt:withNSString:);
  methods[3].selector = @selector(encodeWithByteArray:);
  methods[4].selector = @selector(encodeWithByteArray:withInt:);
  methods[5].selector = @selector(encodeWithByteArray:withInt:withInt:);
  methods[6].selector = @selector(decodeStringWithNSString:);
  methods[7].selector = @selector(decodeLinesWithNSString:);
  methods[8].selector = @selector(decodeWithNSString:);
  methods[9].selector = @selector(decodeWithCharArray:);
  methods[10].selector = @selector(decodeWithCharArray:withInt:withInt:);
  methods[11].selector = @selector(init);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "systemLineSeparator", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 13, -1, -1 },
    { "map1", "[C", .constantValue.asLong = 0, 0x1a, -1, 14, -1, -1 },
    { "map2", "[B", .constantValue.asLong = 0, 0x1a, -1, 15, -1, -1 },
  };
  static const void *ptrTable[] = { "encodeString", "LNSString;", "encodeLines", "[B", "[BIIILNSString;", "encode", "[BI", "[BII", "decodeString", "decodeLines", "decode", "[C", "[CII", &Base64Coder_systemLineSeparator, &Base64Coder_map1, &Base64Coder_map2 };
  static const J2ObjcClassInfo _Base64Coder = { "Base64Coder", "com.mncdigital.analytics", ptrTable, methods, fields, 7, 0x1, 12, 3, -1, -1, -1, -1, -1 };
  return &_Base64Coder;
}

+ (void)initialize {
  if (self == [Base64Coder class]) {
    Base64Coder_systemLineSeparator = JavaLangSystem_getPropertyWithNSString_(@"line.separator");
    Base64Coder_map1 = [IOSCharArray newArrayWithLength:64];
    {
      jint i = 0;
      for (jchar c = 'A'; c <= 'Z'; c++) *IOSCharArray_GetRef(Base64Coder_map1, i++) = c;
      for (jchar c = 'a'; c <= 'z'; c++) *IOSCharArray_GetRef(Base64Coder_map1, i++) = c;
      for (jchar c = '0'; c <= '9'; c++) *IOSCharArray_GetRef(Base64Coder_map1, i++) = c;
      *IOSCharArray_GetRef(Base64Coder_map1, i++) = '+';
      *IOSCharArray_GetRef(Base64Coder_map1, i++) = '/';
    }
    Base64Coder_map2 = [IOSByteArray newArrayWithLength:128];
    {
      for (jint i = 0; i < Base64Coder_map2->size_; i++) *IOSByteArray_GetRef(Base64Coder_map2, i) = -1;
      for (jint i = 0; i < 64; i++) *IOSByteArray_GetRef(Base64Coder_map2, IOSCharArray_Get(Base64Coder_map1, i)) = (jbyte) i;
    }
    J2OBJC_SET_INITIALIZED(Base64Coder)
  }
}

@end

NSString *Base64Coder_encodeStringWithNSString_(NSString *s) {
  Base64Coder_initialize();
  return [NSString java_stringWithCharacters:Base64Coder_encodeWithByteArray_([((NSString *) nil_chk(s)) java_getBytes])];
}

NSString *Base64Coder_encodeLinesWithByteArray_(IOSByteArray *inArg) {
  Base64Coder_initialize();
  return Base64Coder_encodeLinesWithByteArray_withInt_withInt_withInt_withNSString_(inArg, 0, ((IOSByteArray *) nil_chk(inArg))->size_, 76, Base64Coder_systemLineSeparator);
}

NSString *Base64Coder_encodeLinesWithByteArray_withInt_withInt_withInt_withNSString_(IOSByteArray *inArg, jint iOff, jint iLen, jint lineLen, NSString *lineSeparator) {
  Base64Coder_initialize();
  jint blockLen = JreIntDiv((lineLen * 3), 4);
  if (blockLen <= 0) @throw new_JavaLangIllegalArgumentException_init();
  jint lines = JreIntDiv((iLen + blockLen - 1), blockLen);
  jint bufLen = (JreIntDiv((iLen + 2), 3)) * 4 + lines * [((NSString *) nil_chk(lineSeparator)) java_length];
  JavaLangStringBuilder *buf = new_JavaLangStringBuilder_initWithInt_(bufLen);
  jint ip = 0;
  while (ip < iLen) {
    jint l = JavaLangMath_minWithInt_withInt_(iLen - ip, blockLen);
    (void) [buf appendWithCharArray:Base64Coder_encodeWithByteArray_withInt_withInt_(inArg, iOff + ip, l)];
    (void) [buf appendWithNSString:lineSeparator];
    ip += l;
  }
  return [buf description];
}

IOSCharArray *Base64Coder_encodeWithByteArray_(IOSByteArray *inArg) {
  Base64Coder_initialize();
  return Base64Coder_encodeWithByteArray_withInt_withInt_(inArg, 0, ((IOSByteArray *) nil_chk(inArg))->size_);
}

IOSCharArray *Base64Coder_encodeWithByteArray_withInt_(IOSByteArray *inArg, jint iLen) {
  Base64Coder_initialize();
  return Base64Coder_encodeWithByteArray_withInt_withInt_(inArg, 0, iLen);
}

IOSCharArray *Base64Coder_encodeWithByteArray_withInt_withInt_(IOSByteArray *inArg, jint iOff, jint iLen) {
  Base64Coder_initialize();
  jint oDataLen = JreIntDiv((iLen * 4 + 2), 3);
  jint oLen = (JreIntDiv((iLen + 2), 3)) * 4;
  IOSCharArray *out = [IOSCharArray newArrayWithLength:oLen];
  jint ip = iOff;
  jint iEnd = iOff + iLen;
  jint op = 0;
  while (ip < iEnd) {
    jint i0 = IOSByteArray_Get(nil_chk(inArg), ip++) & (jint) 0xff;
    jint i1 = ip < iEnd ? IOSByteArray_Get(inArg, ip++) & (jint) 0xff : 0;
    jint i2 = ip < iEnd ? IOSByteArray_Get(inArg, ip++) & (jint) 0xff : 0;
    jint o0 = JreURShift32(i0, 2);
    jint o1 = (JreLShift32((i0 & 3), 4)) | (JreURShift32(i1, 4));
    jint o2 = (JreLShift32((i1 & (jint) 0xf), 2)) | (JreURShift32(i2, 6));
    jint o3 = i2 & (jint) 0x3F;
    *IOSCharArray_GetRef(out, op++) = IOSCharArray_Get(nil_chk(Base64Coder_map1), o0);
    *IOSCharArray_GetRef(out, op++) = IOSCharArray_Get(Base64Coder_map1, o1);
    *IOSCharArray_GetRef(out, op) = op < oDataLen ? IOSCharArray_Get(Base64Coder_map1, o2) : '=';
    op++;
    *IOSCharArray_GetRef(out, op) = op < oDataLen ? IOSCharArray_Get(Base64Coder_map1, o3) : '=';
    op++;
  }
  return out;
}

NSString *Base64Coder_decodeStringWithNSString_(NSString *s) {
  Base64Coder_initialize();
  return [NSString java_stringWithBytes:Base64Coder_decodeWithNSString_(s)];
}

IOSByteArray *Base64Coder_decodeLinesWithNSString_(NSString *s) {
  Base64Coder_initialize();
  IOSCharArray *buf = [IOSCharArray newArrayWithLength:[((NSString *) nil_chk(s)) java_length]];
  jint p = 0;
  for (jint ip = 0; ip < [s java_length]; ip++) {
    jchar c = [s charAtWithInt:ip];
    if (c != ' ' && c != 0x000d && c != 0x000a && c != 0x0009) *IOSCharArray_GetRef(buf, p++) = c;
  }
  return Base64Coder_decodeWithCharArray_withInt_withInt_(buf, 0, p);
}

IOSByteArray *Base64Coder_decodeWithNSString_(NSString *s) {
  Base64Coder_initialize();
  return Base64Coder_decodeWithCharArray_([((NSString *) nil_chk(s)) java_toCharArray]);
}

IOSByteArray *Base64Coder_decodeWithCharArray_(IOSCharArray *inArg) {
  Base64Coder_initialize();
  return Base64Coder_decodeWithCharArray_withInt_withInt_(inArg, 0, ((IOSCharArray *) nil_chk(inArg))->size_);
}

IOSByteArray *Base64Coder_decodeWithCharArray_withInt_withInt_(IOSCharArray *inArg, jint iOff, jint iLen) {
  Base64Coder_initialize();
  while (iLen > 0 && IOSCharArray_Get(nil_chk(inArg), iOff + iLen - 1) == '=') iLen--;
  jint oLen = JreIntDiv((iLen * 3), 4);
  IOSByteArray *out = [IOSByteArray newArrayWithLength:oLen];
  jint ip = iOff;
  jint iEnd = iOff + iLen;
  jint op = 0;
  while (ip < iEnd) {
    jint i0 = IOSCharArray_Get(nil_chk(inArg), ip++);
    jint i1 = IOSCharArray_Get(inArg, ip++);
    jint i2 = ip < iEnd ? IOSCharArray_Get(inArg, ip++) : 'A';
    jint i3 = ip < iEnd ? IOSCharArray_Get(inArg, ip++) : 'A';
    if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Illegal character in Base64 encoded data.");
    jint b0 = IOSByteArray_Get(nil_chk(Base64Coder_map2), i0);
    jint b1 = IOSByteArray_Get(Base64Coder_map2, i1);
    jint b2 = IOSByteArray_Get(Base64Coder_map2, i2);
    jint b3 = IOSByteArray_Get(Base64Coder_map2, i3);
    if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0) @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Illegal character in Base64 encoded data.");
    jint o0 = (JreLShift32(b0, 2)) | (JreURShift32(b1, 4));
    jint o1 = (JreLShift32((b1 & (jint) 0xf), 4)) | (JreURShift32(b2, 2));
    jint o2 = (JreLShift32((b2 & 3), 6)) | b3;
    *IOSByteArray_GetRef(out, op++) = (jbyte) o0;
    if (op < oLen) *IOSByteArray_GetRef(out, op++) = (jbyte) o1;
    if (op < oLen) *IOSByteArray_GetRef(out, op++) = (jbyte) o2;
  }
  return out;
}

void Base64Coder_init(Base64Coder *self) {
  NSObject_init(self);
}

Base64Coder *new_Base64Coder_init() {
  J2OBJC_NEW_IMPL(Base64Coder, init)
}

Base64Coder *create_Base64Coder_init() {
  J2OBJC_CREATE_IMPL(Base64Coder, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(Base64Coder)

J2OBJC_NAME_MAPPING(Base64Coder, "com.mncdigital.analytics", "")
